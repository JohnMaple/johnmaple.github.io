(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{468:function(s,e,t){"use strict";t.r(e);var a=t(8),n=Object(a.a)({},function(){var s=this,e=s.$createElement,t=s._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"redis-分布式锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-分布式锁","aria-hidden":"true"}},[s._v("#")]),s._v(" Redis 分布式锁")]),s._v(" "),t("p",[s._v("分布式锁本质上要实现的目标就是在 Redis 里面占一个“茅坑”，当别的进程也要来占时，发现已经有人蹲在那里了，就只好放弃或者稍后再试。")]),s._v(" "),t("p",[s._v("占坑一般是使用 "),t("code",[s._v("setnx(set if not exists)")]),s._v(" 指令，只允许被一个客户端占坑。先来先占，用完了，再调用 "),t("code",[s._v("del")]),s._v(" 指令释放茅坑")]),s._v(" "),t("div",{staticClass:"language-sh line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-sh"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("set lock:userxxx "),t("span",{pre:!0,attrs:{class:"token boolean"}},[s._v("true")]),s._v(" ex 5 nx\nOK\n//do something\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("..")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v("del lock:userxxx\n")])]),s._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[s._v("1")]),t("br"),t("span",{staticClass:"line-number"},[s._v("2")]),t("br"),t("span",{staticClass:"line-number"},[s._v("3")]),t("br"),t("span",{staticClass:"line-number"},[s._v("4")]),t("br"),t("span",{staticClass:"line-number"},[s._v("5")]),t("br")])]),t("p",[s._v("超时问题。如果在加锁和释文锁之间逻辑执行的太长，以至于超出了锁的超时限制，就会出现问题。因为锁过期了，第二个线程重新持有了这把锁，但是紧接着第一个线程执行完了业务逻辑，就把锁释放了，第三个线程就会在第二个线程逻辑执行完之间拿到锁。")]),s._v(" "),t("p",[s._v("解决方案：")]),s._v(" "),t("p",[s._v("换zk，用心跳解决\n为set指令的value参数设置为一个随机数，释放时先匹配随机数是否一致，然后再删除key")])])},[],!1,null,null,null);e.default=n.exports}}]);